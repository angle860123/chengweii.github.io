---
layout: post
title: 数据库索引技术
subtitle: 详细介绍数据库索引的应用、原理及注意细节
date: 2017-10-22
author: chengweii
header-img: img/post-bg-hacker.jpg
catalog: true
tags:
    - 数据库
    - 索引
---

# 数据库索引
数据库索引是用于提高数据库表的数据访问速度的。数据库索引的特点：  
* 避免进行数据库全表的扫描，大多数情况，只需要扫描较少的索引页和数据页，而不是查询所有数据页。而且对于非聚集索引，有时不需要访问数据页即可得到数据。
* 聚集索引可以避免数据插入操作，集中于表的最后一个数据页面。
* 在某些情况下，索引可以避免排序操作。

## 聚集索引
![聚集索引](/img/database-index/database-index-1.png)
聚集索引表的数据按照索引的顺序存储。对于聚集索引，叶子结点是存储了真实数据的数据行，不再有单独的数据页。  
在一张表上只能创建一个聚集索引，因为真实数据的物理顺序只可能是一种。  
如果一张表没有聚集索引，name它被称为“堆集”(Heap)。这样的表中的数据行没有特定的顺序，所有的新行将被添加到表的末尾位置。

Mysql InnoDB的数据基于聚集索引存储。在InnoDB表中，其聚集索引相当于整张表，而整张表也是聚集索引。  
每张InnoDB表只能创建一个聚集索引，聚集索引可以由一列或多列组成。  
> InnoDB是聚集索引组织表，聚集索引由引擎自动选择，选择规则如下：主键索引>非NULL唯一索引>ROWID。  

首先选择显式定义的主键索引做为聚集索引;如果没有，则选择第一个不允许NULL的唯一索引;还是没有的话，就采用InnoDB引擎内置的ROWID作为聚集索引。
### 查询
通过聚集索引进行查询时，会进行N次数据页查询。同时查询通常是由磁盘获取，但在访问频率较高时，缓存会保存高层索引，此时查询有可能是从缓存读取。
### 插入
对于聚集索引表，在插入数据时，首先根据索引找到对应的数据页，如果该数据页未满，则挪到已有记录并插入数据；如果数据页已满，则需要新增和拆分数据页。
一般情况下，此时首先检查该数据页的数据段是否已满，如果数据段已满则分配新段，创建数据页并插入数据，然后调整索引指针，这需要将相应的索引页读入内存并加锁，如果该表还有非聚集索引，则需要更新这些索引指向新的数据页。
然而在某些特殊情况下会进行一些特殊处理，如果插入的记录很大，为了提高效率，会分配两个数据页，一个用来存储新纪录，另一个则用来存储拆分出来的记录，通常数据库系统会将重复的记录存储于相同的数据页中。
### 删除
对于聚集索引表，在删除数据时，首先找到记录删除数据，然后检查对应数据页是否为空，如果为空则回收该数据页；检查完数据页后再检查所在数据段，如果为空则回收该数据段；最后更新索引页（删除数据对应索引、合并索引）。
> 索引合并：删除数据可能导致索引页中只有一条记录，该记录会被移至邻近的索引页，原索引页将被回收。

## 非聚集索引
![非聚集索引](/img/database-index/database-index-2.png)
非聚集索引表的数据存储与索引顺序无关。对于非聚集索引，叶子结点包含索引字段值及指向数据页数据行的逻辑指针，该层紧邻数据页，其行数量与数据表行数量一致。
### 查询
通过非聚集索引查询时，会进行N-1次索引页的查询、1次数据页查询。同时查询通常是由磁盘获取，但在访问频率较高时，缓存会保存高层索引，此时查询有可能是从缓存读取。
### 插入
在插入数据时，如果表包含聚集索引，通过聚集索引查询插入位置并插入数据，同时更新非聚集索引；如果表不包含聚集索引，则插入到最末的数据页中，然后更新非聚集索引。
### 删除
删除数据时，首先找到记录删除数据，然后检查对应数据页是否为空，如果为空则回收该数据页；检查完数据页后再检查所在数据段，如果为空则回收该数据段；最后更新索引页（删除数据对应索引、合并索引）。

## 单列索引、复合索引
索引只包含一列的称为单列索引，而包含多列的索引称为复合索引，因为BTREE索引是顺序排列的，所以比较适合范围查询，但是在复合索引中，还应注意列数目、列的顺序以及前面范围查询的列对后边列的影响。

## 索引类型

### 普通索引(Normal)
最基本的索引，它没有任何限制。
```sql
//语法：CREATE INDEX index_name ON table(column(length));
CREATE INDEX idx_test ON test_table(title(4));
```
### 唯一索引(Unique)
唯一索引与普通索引类似，不同的是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
```sql
//语法：CREATE UNIQUE INDEX indexName ON table(column(length));
CREATE UNIQUE INDEX idx_test ON test_table(title(4));
```
### 主键索引
主键索引是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引：
```sql
CREATE TABLE `table` (
         `id` int(11) NOT NULL AUTO_INCREMENT ,
         `title` char(255) NOT NULL ,
         PRIMARY KEY (`id`)
     );
```
### 组合索引
组合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合
```sql
// ALTER TABLE `table` ADD INDEX name_city_age (name,city,age); 
ALTER TABLE `table` ADD INDEX idx_test (name,city,age); 
```
### 全文索引(Full Text)
全文索引主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。
```sql
CREATE TABLE `table` (
    `id` int(11) NOT NULL AUTO_INCREMENT ,
    `title` char(255) CHARACTER NOT NULL ,
    `content` text CHARACTER NULL ,
    PRIMARY KEY (`id`),
    FULLTEXT (content)
);
```

## 索引结构
### BTREE

### HASH
简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，也是对索引列计算一个散列值（类似md5、sha1、crc32），然后对这个散列值以顺序（默认升序）排列，同时记录该散列值对应数据表中某行的指针，当然这只是简略模拟图。
哈希索引的结构决定了它的特点：
1.hash索引只是hash值顺序排列，跟表数据没有关系，无法应用于order by；
2.hash索引是对它的所有列计算哈希值，因此在查询时，必须带上所有列，比如有(a, b)哈希索引，查询时必须 where a = 1 and b = 2，少任何一个不行；
3.hash索引只能用于比较查询 = 或 IN，其他范围查询无效，本质还是因不存储表数据；
4.一旦出现碰撞，hash索引必须遍历所有的hash值，将地址所指向数据一一比较，直到找到所有符合条件的行。

### BITMAP(Oracle)
如果对于性别列（男或女）等，则使用位图索引会比较好，因为它对空间的占用非常少（因为都是用bit位来表示表里的数据行），从而在扫描索引的时候，扫描的索引块的个数也比较少。  
如果索引列上不同值的个数比较少的时候  
注意：如果被索引的列经常被更新的话，则不适合使用位图索引。因为在更新索引条目的过程中，会锁定位图索引里多个索引条目。也就是同时只能有一个用户能够更新表T，从而降低了并发性。位图索引比较适合用在数据仓库系统里，不适合用在OLTP系统里。

## MySQL索引实现
在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的。
### MyISAM索引实现
MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：
![主索引](/img/database-index/database-index-3.png)
该表共有三列，Col1为主键。可以看出MyISAM的索引文件仅仅保存数据记录的地址。
> 在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。

如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：
![辅助索引](/img/database-index/database-index-4.png)
同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。  
MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。
### InnoDB索引实现
> 虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。第一个重大区别是InnoDB的数据文件本身就是索引文件。

从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。
![主索引](/img/database-index/database-index-5.png)
从图中可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。
> 因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。

第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，在Col3定义上的一个辅助索引：
![辅助索引](/img/database-index/database-index-6.png)
这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。
## 索引优化
MySQL的优化主要分为结构优化（Scheme optimization）和查询优化（Query optimization）。  
在了解具体优化策略之前，首先要理解索引使用的一些原则，包括：最左前缀原则、索引选择性。
### 最左前缀原则
### 索引选择性与前缀索引

接下来我们从结构优化和查询优化两方面来了解一些具体的优化手段：
### 结构优化
* 在InnoDB中不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。
* 在InnoDB中不建议用非单调的字段作为主键，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。
### 查询优化

### InnoDB的主键选择与优化

# 参考文献
[MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)  
[数据库索引详解](http://www.cnblogs.com/gavinsp/p/5513536.html)  
[MySQL的聚集索引和非聚集索引](http://www.cnblogs.com/wyy123/p/6269875.html)  
[MySQL表为什么必须有主键 -- 聚集索引的简单介绍](http://blog.csdn.net/jhgdike/article/details/60579883)  
[聚集索引、非聚集索引、聚集索引组织表、堆组织表、Mysql/PostgreSQL对比、联合主键/自增长、InnoDB/MyISAM（引擎方面另开一篇）](https://www.cnblogs.com/charlesblc/p/5983234.html)  
[聚集索引和非聚集索引（整理）](http://www.cnblogs.com/aspnethot/articles/1504082.html)  
[Mysql技术内幕——InnoDB存储引擎](https://jingyan.baidu.com/article/fedf07377c493f35ac89770c.html)  
[oracle索引原理（b-tree,bitmap,聚集，非聚集索引）](http://blog.csdn.net/chenleixing/article/details/48153295)  