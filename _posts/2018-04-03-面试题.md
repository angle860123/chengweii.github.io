---
layout: post
title: 面试题
subtitle: 常见面试题汇总。
date: 2018-04-03
author: chengweii
header-img: img/post-bg-hacker.jpg
catalog: true
tags:
    - 面试
    - java
---

# 基本概念
## 什么是面向对象编程？
通过建模形式抽象思维过程的编程方法。面向对象编程的核心思想体现在四个方面：抽象、封装、继承、多态。  
* 抽象
    * 抽象是定义对象的属性和行为，具体体现为将同一类对象(模型)的数据和行为定义为类。
* 封装
    * 封装是一种信息隐蔽技术，隐藏一切可隐藏的数据或行为，只对外提供最简单的操作数据的接口。
* 继承
    * 继承是从已有类得到继承信息创建新类的过程。继承不仅支持了系统的可重用性，而且还促进了系统的可扩充性。
* 多态
    * 多态是指允许不同子类型的对象对同一消息作出不同的响应。   
    
## 操作系统中heap和stack的区别？
1.功能方面，Stack空间用来存储基础类型的值和对象引用，Heap则用来存储对象和数组。  
2.使用方面，Stack空间由操作系统自动分配释放，Heap空间由程序员手动申请释放。  
3.限制方面，Stack空间有限，Heap则是空间很大的自由区。  
4.效率方面，Stack简单、速度快；Heap灵活，但是速度慢且容易产生内存碎片。  

## 什么是AOP？
切面编程（AOP）是通过切面非侵入式的操作程序方法，常用的场景如日志记录、权限判断、读写分离等，其原理是基于动态代理技术实现，通过ProxyBeanFactory配置工厂bean，将实现MethodInterceptor接口的拦截器链织入到代理Bean中，完成方法调用拦截。具体实现是通过@AspectJ注解将Bean转换为一个aspectj切面，通过@Pointcut、@Before、@After、@Around注解定制具体的切面织入的内容。  

## 什么是IOC？
IOC/DI:控制反转，本质是将原来程序中对象创建、依赖的代码，反转交由容器去协助实现以达到统一管理对象的目的。Spring中的IOC容器，它的主要作用是完成对象的创建和依赖的管理注入等等。
>依赖注入可以通过setter方法注入（设值注入）、构造器注入和接口注入三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象。

## 什么是ORM？
对象关系映射（Object-Relational Mapping，简称ORM）是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术；简单的说，ORM是将程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转换成Java对象，其本质上就是将数据从一种形式转换到另外一种形式。

## 什么是反射？
反射是指程序可以访问、检测和修改它本身状态或行为的一种能力，反射的用途主要有：获取类型的相关信息，动态调用方法，动态构造对象，从程序集中获得类型。

## 事务特性ACID是什么？
- 原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败；  
- 一致性(Consistent)：事务结束后系统状态是一致的；   
- 隔离性(Isolated)：并发执行的事务彼此无法看到对方的中间状态；   
- 持久性(Durable)：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。  

## 数据库隔离级别是有哪些？
数据库为我们提供的四种隔离级别：  
① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。  
② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。  
③ Read committed (读已提交)：可避免脏读的发生。  
④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。  
![隔离级别问题](/img/interview/interview-2.png)  

## 什么是脏读、幻读、不可重复读、第一类丢失更新、第二类丢失更新？
脏读：指在一个事务处理过程里读取了另一个未提交的事务中的数据。    
不可重复读：在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。  
幻读：幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。  
第一类丢失更新：事务A撤销时，覆盖事务B已经提交的数据，造成事务B所做操作丢失。  
第二类丢失更新：事务A提交时，覆盖事务B已经提交的数据，造成事务B所做操作丢失。  

## 阐述下SOLID原则？
1、单一职责原则（Single Responsibility Principle）：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。  
2、开闭原则（Open-Close Principle）：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。  
3、里氏替换原则（Liskov Substitution Priciple）：子类可以扩展父类的功能，但不能改变父类原有的功能。  
子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。子类中可以增加自己特有的方法。当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。  
4、依赖倒置原则（Dependence Inversion Principle）：要依赖于抽象，不要依赖于具体。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。   
5、接口隔离原则（Interface Segregation Principle）：拆分非常庞大臃肿的接口成为更小的和更具体的接口，使用多个专门的接口比使用单一的总接口要好。目的是系统解开耦合，从而容易重构，更改和重新部署。  
6、最少知识原则（Least Knowledge Principle）：迪米特法则（Law of Demeter）又叫作最少知道原则（Least Knowledge Principle 简写LKP），就是说一个对象应当对其他对象有尽可能少的了解,不和陌生人说话。门面模式和调停者模式实际上就是迪米特法则的应用。广义的迪米特法则在类的设计上的体现：优先考虑将一个类设置成不变类。尽量降低一个类的访问权限。谨慎使用Serializable。尽量降低成员的访问权限。  

## BS、CS、P2P架构的联系与区别？
典型的网络应用模式大致有三类：B/S、C/S、P2P。其中B代表浏览器（Browser）、C代表客户端（Client）、S代表服务器（Server），P2P是对等模式，不区分客户端和服务器。  
B/S应用模式中可以视为特殊的C/S应用模式，只是将C/S应用模式中的特殊的客户端换成了浏览器，因为几乎所有的系统上都有浏览器，那么只要打开浏览器就可以使用应用，没有安装、配置、升级客户端所带来的各种开销。  
P2P应用模式中，成千上万台彼此连接的计算机都处于对等的地位，整个网络一般来说不依赖专用的集中服务器。网络中的每一台计算机既能充当网络服务的请求者，又对其它计算机的请求作出响应，提供资源和服务。通常这些资源和服务包括：信息的共享和交换、计算资源（如CPU的共享）、存储共享（如缓存和磁盘空间的使用）等，这种应用模式最大的阻力安全性、版本等问题，目前有很多应用都混合使用了多种应用模型，最常见的网络视频应用，它几乎把三种模式都用上了。
> 补充：此题要跟"电子商务模式"区分开，因为有很多人被问到这个问题的时候马上想到的是B2B（如阿里巴巴）、B2C（如当当、亚马逊、京东）、C2C（如淘宝、拍拍）、C2B（如威客）、O2O（如美团、饿了么）。对于这类问题，可以去百度上面科普一下。

## 什么是SOAP、WSDL、UDDI？
- SOAP：简单对象访问协议（Simple Object Access Protocol），是Web Service中交换数据的一种协议规范。   
- WSDL：Web服务描述语言（Web Service Description Language），它描述了Web服务的公共接口。这是一个基于XML的关于如何与Web服务通讯和使用的服务描述；也就是描述与目录中列出的Web服务进行交互时需要绑定的协议和信息格式。通常采用抽象语言描述该服务支持的操作和信息，使用的时候再将实际的网络协议和信息格式绑定给该服务。   
- UDDI：统一描述、发现和集成（Universal Description, Discovery and Integration），它是一个基于XML的跨平台的描述规范，可以使世界范围内的企业在互联网上发布自己所提供的服务。简单的说，UDDI是访问各种WSDL的一个门面（可以参考设计模式中的门面模式）。  

## XML与JSON的区别？
XML与JSON都是简单、人类可读的数据格式，二者应用场景有所不同：  
XML更适合数据定义、数据存储、高级检索（XPath），由于其标记语言标准、规范、强类型的特性使其更易于被机器理解、实现跨平台交互，HTML是XML应用成功的有力案例（其实大部分UI语言XAML等使用JSON作为数据交换语言都是一场灾难，因为相对于XML，JSON由于其弱类型的特性，致使它在数据定义、数据检查、数据检索等方面要差的多）。  
JSON则更适合于数据传输，由于其作为一种轻量级数据交换语言的特性，其占用空间更少、传输和解析速度更快，所以现在大部分API服务都在使用JSON作为数据传输语言，例如：微信、高德。

## JRE、JDK、JVM、JIT的联系与区别？
JRE代表 Java 运行时（Java run-time），是运行 Java 引用所必须的。  
JDK代表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java 编译器，它也包含 JRE。  
JVM代表 Java 虚拟机（Java virtual machine），它的责任是运行 Java 应用。  
JIT 代表即时编译（Just In Time compilation），当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被转换为本地代码，这样有利大幅度提高 Java 应用的性能。  

## MVC是什么，具体如何实现？ 

## RPC 和 RMI 区别？
RPC是远程过程调用协议，通过网络从远程计算机上请求调用某种服务，具体应用有Dubbo；RMI是远程方法调用框架，JAVA中通过RMI实现跨JVM进行远程方法调用。二者的区别是：  
1.二者方法调用的方式不同，RPC是通过网络协议向远程主机发送请求，而RMI则是通过在客户端的Stub对象作为接口进行远程方法调用。  
2.二者适用语言范围不同，RPC是网络协议，与操作系统和语言无关，而RMI则只适用于JAVA。
3.二者调用结果的返回形式不同，RPC传送的消息由外部数据表示 (ExternalData Representation,XDR) 语言表示，这种语言抽象了字节序类和数据类型结构之间的差异。只有由 XDR 定义的数据类型才能被传递， RPC 不允许传递对象。而RMI调用远程对象方法，允许方法返回 Java 对象以及基本数据类型。

## 实现会话跟踪的技术有哪些？
由于HTTP协议本身是无状态的，服务器为了区分不同的用户，就需要对用户会话进行跟踪，简单的说就是为用户进行登记，为用户分配唯一的ID，下一次用户在请求中包含此ID，服务器据此判断到底是哪一个用户。   
①URL 重写：在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。    
②设置表单隐藏域：将和会话跟踪相关的字段添加到隐式表单域中，这些信息不会在浏览器中显示但是提交表单时会提交给服务器。    
这两种方式很难处理跨越多个页面的信息传递，因为如果每次都要修改URL或在页面中添加隐式表单域来存储用户会话相关信息，事情将变得非常麻烦。    
③cookie：cookie有两种，一种是基于窗口的，浏览器窗口关闭后，cookie就没有了；另一种是将信息存储在一个临时文件中，并设置存在的时间。当用户通过浏览器和服务器建立一次会话后，会话ID就会随响应信息返回存储在基于窗口的cookie中，那就意味着只要浏览器没有关闭，会话没有超时，下一次请求时这个会话ID又会提交给服务器让服务器识别用户身份。会话中可以为用户保存信息。会话对象是在服务器内存中的，而基于窗口的cookie是在客户端内存中的。如果浏览器禁用了cookie，那么就需要通过下面两种方式进行会话跟踪。当然，在使用cookie时要注意几点：首先不要在cookie中存放敏感信息；其次cookie存储的数据量有限（4k），不能将过多的内容存储cookie中；再者浏览器通常只允许一个站点最多存放20个cookie。当然，和用户会话相关的其他信息（除了会话ID）也可以存在cookie方便进行会话跟踪。    
④HttpSession：在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建HttpSession，每个用户可以访问他自己的HttpSession。可以通过HttpServletRequest对象的getSession方法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象。与上面三种方式不同的是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession中的对象移到其他存储设备中，但是这样势必影响性能。添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。   
>HTML5中可以使用Web Storage技术通过JavaScript来保存数据，例如可以使用localStorage和sessionStorage来保存用户会话的信息，也能够实现会话跟踪。

## 简述一下你了解的设计模式。


# 基础
## String是最基本的数据类型吗？
不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（reference type），Java 5以后引入的枚举类型也算是一种比较特殊的引用类型。

## float f=3.4;是否正确？
不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。 

## short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？ 
对于short s1=1; s1=s1+1;由于1是int类型，因此s1+1运算结果也是int型，需要强制转换类型才能赋值给short型。而short s1=1; s1+=1;可以正确编译，因为s1+=1;相当于s1=(short)(s1 + 1);其中有隐含的强制类型转换。

## &和&&的区别？
&运算符有两种用法：(1)按位与；(2)逻辑与。&&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&&之所以称为短路运算是因为，如果&&左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。

## Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？ 
Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。

## switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？ 
在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。

## 用最有效率的方法计算2乘以8？ 
2 << 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。

## 对象的hashCode有什么要求？
1.两个相同的对象必须要有相同的hashCode，两个不相等的对象允许有相同的 hashcode 值  
2.对象的hashCode必须始终是一致的，不可以是随机数  

## 为什么在重写 equals 方法的时候需要重写 hashCode 方法？
因为有强制的规范指定需要同时重写 hashCode 与 equals 方法，许多容器类，如 HashMap、HashSet 都依赖于 hashCode 与 equals 的规定。

## “a==b”和”a.equals(b)”有什么区别？
如果 a 和 b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。

## 是否可以继承String类？ 
String 类是final类，不可以被继承。

## String和StringBuilder、StringBuffer的区别？ 
Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。

## 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？ 
方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。不能根据返回类型来区分重载。

## 为什么不能根据返回类型区分重载？
因为调用时如果不能指定返回类型信息时，编译器是不知道你要调用哪个函数的，函数的返回值只是作为函数运行之后的一个“状态”，并不能作为某个方法的“标识”。

## char 型变量中能不能存贮一个中文汉字，为什么？ 
char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16比特），所以放一个中文是没问题的。

## 抽象类（abstract class）和接口（interface）有什么异同？ 
相同：
1.抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。  
2.一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。  
不同：  
1.接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。  
2.抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。  
3.抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。  

## 阐述静态变量和实例变量的区别。 
1.静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝。  
2.实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。

## 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？
不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。

## 如何实现对象克隆？ 
有两种方式： 
1). 实现Cloneable接口并重写Object类中的clone()方法。  
2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。

## final、finalize 和 finally 的不同之处？
final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变；修饰类，表示该类不能被继承；修饰方法，表示方法不能被重写。  
finalize 方法是在对象被回收之前调用的方法，给对象自己最后一个复活的机会，但是如同对象何时被GC无法被保证，什么时候调用 finalize 也无法保证。  
finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。  

## 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？ 
一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。

## Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？
可以继承其他类或实现其他接口，在Android开发中常用此方式来实现事件监听和回调。

## Error和Exception有什么区别？
Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。

## try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后? 
会执行，在方法返回调用者前执行。

## 列出一些你常见的运行时异常？ 
- ArithmeticException（算术异常）  
- ClassCastException （类转换异常）   
- IllegalArgumentException （非法参数异常）   
- IndexOutOfBoundsException （下标越界异常）   
- NullPointerException （空指针异常）   
- SecurityException （安全异常）  

## 实现集合排序的方式有哪些？
1.使用有序集合，如 TreeSet、TreeMap，注意如果不提供Comparator的话，对象需实现Comparable接口,重写其compareTo()方法  
2.使用顺序集合，如 List（ArrayList、LinkedList），然后通过 Collections.sort(List<T> list) 来排序，对象需实现Comparable接口,重写其compareTo()方法

## Java中如何实现序列化，有什么意义？ 
序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。  
要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆。

## Java中有几种类型的流？ 
字节流和字符流。字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer。在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。关于Java的I/O需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。

## List、Set、Map 和 Queue 之间的区别？
List 是一个有序集合，允许元素重复。它的某些实现可以提供基于下标值的常量访问时间，但是这不是 List 接口保证的。Set 是一个无序集合。

## poll() 方法和 remove() 方法的区别？
poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。

## Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？
PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，但是 LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。

## ArrayList 与 LinkedList 的不区别？
最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。

## 写一段代码在遍历 ArrayList 时移除一个元素？
通过Iterator遍历时不可进行更新操作，通过索引遍历（for(index=0;index<list.size();index++){list.get(index);}）时则可以。

## ArrayList 和 HashMap 的默认大小是多少？
在 Java 7 中，ArrayList 的默认大小是 10 个元素，HashMap 的默认大小是16个元素（必须是2的幂）。这就是 Java 7 中 ArrayList 和 HashMap 类的代码片段：
```java
// from ArrayList.java JDK 1.7
private static final int DEFAULT_CAPACITY = 10;
//from HashMap.java JDK 7
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
```

# 多线程
## 线程的基本状态以及状态之间的关系？
![线程状态切换](/img/interview/interview-1.png)  
说明：其中Running表示运行状态，Runnable表示就绪状态（万事俱备，只欠CPU），Blocked表示阻塞状态，阻塞状态又有多种情况，可能是因为调用wait()方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了sleep()方法或join()方法等待休眠或其他线程结束，或是因为发生了I/O中断。

## Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别? 
sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态）。  
wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。

## 编写多线程程序有几种实现方式？ 
Java 5以前实现多线程有两种实现方法：一种是继承Thread类；另一种是实现Runnable接口。  
两种方式都要通过重写run()方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了，显然使用Runnable接口更为灵活。注意：Thread类也是Runnable接口的子类。  
Java 5以后创建线程还有第三种方式：实现Callable接口，配合线程池框架使用，该接口中的call方法可以在线程执行结束时产生一个返回值。  
```java
ExecutorService threadPool = Executors.newSingleThreadExecutor();
Future<String> future = threadPool.submit(new MyThread());
```

## 线程同步有哪些方式？

## 启动一个线程是调用run()还是start()方法？ 
启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。

## 简述synchronized 和java.util.concurrent.locks.Lock的异同？
Lock是Java 5以后引入的新的API，和关键字synchronized相比主要相同点：Lock 能完成synchronized所实现的所有功能；  
主要不同点：  
1.Lock有比synchronized更精确的线程语义、更细的锁粒度、更好的性能，而且不强制性的要求一定要获得锁，获取失败后还可以有其他选择，而synchronized必须获取锁才能继续向下执行。  
2.synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且最好在finally 块中释放（这是释放外部资源的最好的地方）。

# Servlet
## 阐述Servlet和CGI的区别?
Servlet与CGI的区别在于Servlet处于服务器进程中，它通过多线程方式运行其service()方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于Servlet。

## 转发（forward）和重定向（redirect）的区别？
forward是容器中控制权的转向，是服务器请求资源，服务器直接访问目标地址的URL，把那个URL 的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。redirect就是服务器端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址，因此从浏览器的地址栏中可以看到跳转后的链接地址，很明显redirect无法访问到服务器保护起来资源，但是可以从一个网站redirect到其他网站。forward更加高效，所以在满足需要时尽量使用forward（通过调用RequestDispatcher对象的forward()方法，该对象可以通过ServletRequest对象的getRequestDispatcher()方法获得），并且这样也有助于隐藏实际的链接；在有些情况下，比如需要访问一个其它服务器上的资源，则必须使用重定向（通过HttpServletResponse对象调用其sendRedirect()方法实现）。

## 过滤器有哪些作用和用法?
Java Web开发中的过滤器（filter）是从Servlet 2.3规范开始增加的功能，并在Servlet 2.4规范中得到增强。对Web应用来说，过滤器是一个驻留在服务器端的Web组件，它可以截取客户端和服务器之间的请求与响应信息，并对这些信息进行过滤。当Web容器接受到一个对资源的请求时，它将判断是否有过滤器与这个资源相关联。如果有，那么容器将把请求交给过滤器进行处理。在过滤器中，你可以改变请求的内容，或者重新设置请求的报头信息，然后再将请求发送给目标资源。当目标资源对请求作出响应时候，容器同样会将响应先转发给过滤器，在过滤器中你可以对响应的内容进行转换，然后再将响应发送到客户端。  
常见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件、对XML的输出应用XSLT等。  
和过滤器相关的接口主要有：Filter、FilterConfig和FilterChain。

## 监听器有哪些作用和用法？
Java Web开发中的监听器（listener）就是application、session、request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件，如下所示：   
①ServletContextListener：对Servlet上下文的创建和销毁进行监听。   
②ServletContextAttributeListener：监听Servlet上下文属性的添加、删除和替换。   
③HttpSessionListener：对Session的创建和销毁进行监听。  
补充：session的销毁有两种情况：1). session超时（可以在web.xml中通过<session-config>/<session-timeout>标签配置超时时间）；2). 通过调用session对象的invalidate()方法使session失效。  
④HttpSessionAttributeListener：对Session对象中属性的添加、删除和替换进行监听。   
⑤ServletRequestListener：对请求对象的初始化和销毁进行监听。   
⑥ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听。  

## web.xml文件中可以配置哪些内容？
web.xml用于配置Web应用的相关信息，如：监听器（listener）、过滤器（filter）、 Servlet、相关参数、会话超时时间、安全验证方式、错误页面等，下面是一些开发中常见的配置：  
①配置Spring上下文加载监听器加载Spring配置文件并创建IoC容器：  
```
<context-param>
 <param-name>contextConfigLocation</param-name>
<param-value>classpath:applicationContext.xml</param-value>
</context-param>

<listener>
 <listener-class>
   org.springframework.web.context.ContextLoaderListener
 </listener-class>
</listener>
```
②配置Spring的OpenSessionInView过滤器来解决延迟加载和Hibernate会话关闭的矛盾：  
```
<filter>
  <filter-name>openSessionInView</filter-name>
  <filter-class>
     org.springframework.orm.hibernate3.support.OpenSessionInViewFilter
  </filter-class>
</filter>

<filter-mapping>
  <filter-name>openSessionInView</filter-name>
  <url-pattern>/*</url-pattern>
</filter-mapping>
```
③配置会话超时时间为10分钟：  
```
<session-config>
  <session-timeout>10</session-timeout>
</session-config>
```
④配置404和Exception的错误页面：  
```
<error-page>
  <error-code>404</error-code>
  <location>/error.jsp</location>
</error-page>

<error-page>
  <exception-type>java.lang.Exception</exception-type>
  <location>/error.jsp</location>
</error-page>
```
⑤配置安全认证方式：  
```
<security-constraint>
  <web-resource-collection>
      <web-resource-name>ProtectedArea</web-resource-name>
      <url-pattern>/admin/*</url-pattern>
      <http-method>GET</http-method>
      <http-method>POST</http-method>
  </web-resource-collection>
  <auth-constraint>
      <role-name>admin</role-name>
  </auth-constraint>
</security-constraint>

<login-config>
  <auth-method>BASIC</auth-method>
</login-config>

<security-role>
  <role-name>admin</role-name>
</security-role>
```
说明：对Servlet（小服务）、Listener（监听器）和Filter（过滤器）等Web组件的配置，Servlet 3规范提供了基于注解的配置方式，可以分别使用@WebServlet、@WebListener、@WebFilter注解进行配置。

## Servlet 3中的异步处理指的是什么？
在Servlet 3中引入了一项新的技术可以让Servlet异步处理请求。有人可能会质疑，既然都有多线程了，还需要异步处理请求吗？答案是肯定的，因为如果一个任务处理时间相当长，那么Servlet或Filter会一直占用着请求处理线程直到任务结束，随着并发用户的增加，容器将会遭遇线程超出的风险，这这种情况下很多的请求将会被堆积起来而后续的请求可能会遭遇拒绝服务，直到有资源可以处理请求为止。异步特性可以帮助应用节省容器中的线程，特别适合执行时间长而且用户需要得到结果的任务，如果用户不需要得到结果则直接将一个Runnable对象交给Executor并立即返回即可。
```java
@Override
public void doGet(HttpServletRequest req, HttpServletResponse resp) 
        throws ServletException, IOException {
    req.setAttribute("org.apache.catalina.ASYNC_SUPPORTED", true);
    final AsyncContext ctx = req.startAsync();
    ctx.start(new Runnable() {
        @Override
        public void run() {
            ctx.complete();
        }
    });
}
```

#Spring
## Spring中自动装配的方式有哪些？ 
- no：不进行自动装配，手动设置Bean的依赖关系。 
- byName：根据Bean的名字进行自动装配。 
- byType：根据Bean的类型进行自动装配。 
- constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。 
- autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配。
>说明：自动装配没有自定义装配方式那么精确，而且不能自动装配简单属性（基本类型、字符串等），在使用时应注意。

## 你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？
1. 连接点（Joinpoint）：程序执行的某个特定位置（如：某个方法调用前、调用后，方法抛出异常后）。一个类或一段程序代码拥有一些具有边界性质的特定点，这些代码中的特定点就是连接点。Spring仅支持方法的连接点。   
2. 切点（Pointcut）：如果连接点相当于数据中的记录，那么切点相当于查询条件，一个切点可以匹配多个连接点。Spring AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。   
3. 增强（Advice）：增强是织入到目标类连接点上的一段程序代码。Spring提供的增强接口都是带方位名的，如：BeforeAdvice、AfterReturningAdvice、ThrowsAdvice等。很多资料上将增强译为“通知”，这明显是个词不达意的翻译，让很多程序员困惑了许久。  
4. 引介（Introduction）：引介是一种特殊的增强，它为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过引介功能，可以动态的未该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。   
5. 织入（Weaving）：织入是将增强添加到目标类具体连接点上的过程，AOP有三种织入方式：①编译期织入：需要特殊的Java编译期（例如AspectJ的ajc）；②装载期织入：要求使用特殊的类加载器，在装载类的时候对类进行增强；③运行时织入：在运行时为目标类生成代理实现增强。Spring采用了动态代理的方式实现了运行时织入，而AspectJ采用了编译期织入和装载期织入的方式。   
6. 切面（Aspect）：切面是由切点和增强（引介）组成的，它包括了对横切关注功能的定义，也包括了对连接点的定义。  

## Spring中如何使用注解来配置Bean？有哪些相关的注解？
首先需要在Spring配置文件中增加如下配置：
```
<context:component-scan base-package="org.example"/>
```
然后可以用@Component、@Controller、@Service、@Repository注解来标注需要由Spring IoC容器进行对象托管的类。这几个注解没有本质区别，只不过@Controller通常用于控制器，@Service通常用于业务逻辑类，@Repository通常用于仓储类（例如我们的DAO实现类），普通的类用@Component来标注。

## Spring支持的事务管理类型有哪些？你在项目中使用哪种方式？ 
Spring支持编程式事务管理和声明式事务管理。许多Spring框架的用户选择声明式事务管理，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理，因为编程式事务允许你通过代码控制业务。
事务分为全局事务和局部事务。全局事务由应用服务器管理，需要底层服务器JTA支持（如WebLogic、WildFly等）。局部事务和底层采用的持久化方案有关，例如使用JDBC进行持久化时，需要使用Connetion对象来操作事务；而采用Hibernate进行持久化时，需要使用Session对象来操作事务。
Spring提供了如下所示的事务管理器。  
DataSourceTransactionManager(注入DataSource)【常用】  
HibernateTransactionManager(注入SessionFactory)  
JdoTransactionManager(管理JDO事务)  
JtaTransactionManager(使用JTA管理事务)  
PersistenceBrokerTransactionManager(管理Apache的OJB事务)  

## Spring MVC的工作原理是怎样的？
Spring MVC的工作原理如下图所示： 
![Spring MVC工作原理](/img/interview/interview-3.png)  
① 客户端的所有请求都交给前端控制器DispatcherServlet来处理，它会负责调用系统的其他模块来真正处理用户的请求。   
② DispatcherServlet收到请求后，将根据请求的信息（包括URL、HTTP协议方法、请求头、请求参数、Cookie等）以及HandlerMapping的配置找到处理该请求的Handler（任何一个对象都可以作为请求的Handler）。   
③在这个地方Spring会通过HandlerAdapter对该处理器进行封装。   
④ HandlerAdapter是一个适配器，它用统一的接口对各种Handler中的方法进行调用。   
⑤ Handler完成对用户请求的处理后，会返回一个ModelAndView对象给DispatcherServlet，ModelAndView顾名思义，包含了数据模型以及相应的视图的信息。   
⑥ ModelAndView的视图是逻辑视图，DispatcherServlet还要借助ViewResolver完成从逻辑视图到真实视图对象的解析工作。   
⑦ 当得到真正的视图对象后，DispatcherServlet会利用视图对象对模型数据进行渲染。   
⑧ 客户端得到响应，可能是一个普通的HTML页面，也可以是XML或JSON字符串，还可以是一张图片或者一个PDF文件。  

## 阐述Spring框架中Bean的生命周期？
① Spring IoC容器找到关于Bean的定义并实例化该Bean。   
② Spring IoC容器对Bean进行依赖注入。   
③ 如果Bean实现了BeanNameAware接口，则将该Bean的id传给setBeanName方法。   
④ 如果Bean实现了BeanFactoryAware接口，则将BeanFactory对象传给setBeanFactory方法。   
⑤ 如果Bean实现了BeanPostProcessor接口，则调用其postProcessBeforeInitialization方法。   
⑥ 如果Bean实现了InitializingBean接口，则调用其afterPropertySet方法。   
⑦ 如果有和Bean关联的BeanPostProcessors对象，则这些对象的postProcessAfterInitialization方法被调用。   
⑧ 当销毁Bean实例时，如果Bean实现了DisposableBean接口，则调用其destroy方法。  

## Spring MVC与Struts的区别？你会选哪个？
1.Spring MVC核心控制器是Servlet，而Struts2是Filter。  
2.Spring Mvc会比Struts快一些（理论上）。Spring Mvc是基于方法设计，而Sturts是基于对象，每次发一次请求都会实例一个action，每个action都会被注入属性，而Spring更像Servlet一样，只有一个实例，每次请求执行对应的方法即可(注意：由于是单例实例，所以应当避免全局变量的修改，这样会产生线程安全问题)。  
3.Spring框架对Spring MVC支持更好，而且提供了全注解方式进行管理，各种功能的注解都比较全面，使用简单，而Struts2需要采用XML很多的配置参数来管理。  
4.Struts2中自身提供多种参数接受，其实都是通过（ValueStack）进行传递和赋值，而Spring MVC是通过方法的参数进行接收。  
5.Spring MVC相对于Struts2使用更为简单，学习成本更低。  
6.Struts有自己的interceptor机制，Spring MVC用的是独立的AOP方式。Spring MVC是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应，所以说从架构本身上Spring MVC就容易实现restful url。Struts2是类级别的拦截，一个类对应一个request上下文；实现restful url要费劲，因为Struts2 action的一个方法可以对应一个url；而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了。Spring MVC的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架方法之间不共享变量，而Struts2搞的就比较乱，虽然方法之间 也是独立的，但其所有Action变量是共享的，这不会影响程序运行，却给我们编码，读程序时带来麻烦。  
7.Spring MVC处理ajax请求,直接通过返回数据，方法中使用注解@ResponseBody，Spring MVC自动帮我们对象转换为JSON数据。

# JVM
## 描述一下JVM加载class文件的原理机制？
JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。 
由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。 
类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：

Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；
Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；
System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。

## 解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。 
通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用JVM中的栈空间；而通过new关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor（又可分为From Survivor和To Survivor）、Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的100、"hello"和常量都是放在常量池中，常量池是方法区的一部分，。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发StackOverflowError，而堆和常量池空间不足则会引发OutOfMemoryError。

## GC是什么？为什么要有GC？


## 你能保证 GC 执行吗？
不能，虽然你可以调用 System.gc() 或者 Runtime.gc()，但是没有办法保证 GC 的执行。

# 开放性问题
## 比较一下Java和JavaSciprt
1.面向对象和基于对象：Java是一种面向对象语言，必须设计对象，而后进行编程；JavaScript是一种脚本语言，基于对象（Object-Based）和事件驱动（Event-Driven）进行编程。  
2.编译和解释：Java的源代码在执行之前，必须经过编译，而后再进行解释执行。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器直接解释执行。   
3.强类型和弱类型：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。 

## 你用过的网站前端优化的技术有哪些？
① 浏览器访问优化： 
- 减少HTTP请求数量：合并CSS、合并JavaScript、合并图片（CSS Sprite） 
- 使用浏览器缓存：通过设置HTTP响应头中的Cache-Control和Expires属性，将CSS、JavaScript、图片等在浏览器中缓存，当这些静态资源需要更新时，可以更新HTML文件中的引用来让浏览器重新请求新的资源 
- 启用压缩 
- CSS前置，JavaScript后置 
- 减少Cookie传输（精简Cookie，域名独立Cookie独立）   
② CDN加速：CDN（Content Distribute Network）的本质仍然是缓存，将数据缓存在离用户最近的地方，CDN通常部署在网络运营商的机房，不仅可以提升响应速度，还可以减少应用服务器的压力。当然，CDN缓存的通常都是静态资源。   
③ 反向代理：反向代理相当于应用服务器的一个门面，可以保护网站的安全性，也可以实现负载均衡的功能，当然最重要的是它缓存了用户访问的热点资源，可以直接从反向代理将某些内容返回给用户浏览器。

## 你使用过的应用服务器优化技术有哪些？ 
① 分布式缓存：  
缓存的本质就是内存中的哈希表，如果设计一个优质的哈希函数，那么理论上哈希表读写的渐近时间复杂度为O(1)。缓存主要用来存放那些读写比很高、变化很少的数据，这样应用程序读取数据时先到缓存中读取，如果没有或者数据已经失效再去访问数据库或文件系统，并根据拟定的规则将数据写入缓存。对网站数据的访问也符合二八定律（Pareto分布，幂律分布），即80%的访问都集中在20%的数据上，如果能够将这20%的数据缓存起来，那么系统的性能将得到显著的改善。当然，使用缓存需要解决以下几个问题： 
- 频繁修改的数据； 
- 数据不一致与脏读； 
- 缓存雪崩（可以采用分布式缓存服务器集群加以解决，memcached是广泛采用的解决方案）； 
- 缓存预热； 
- 缓存穿透（恶意持续请求不存在的数据）。   
② 异步操作：可以使用消息队列将调用异步化，通过异步处理将短时间高并发产生的事件消息存储在消息队列中，从而起到削峰作用。电商网站在进行促销活动时，可以将用户的订单请求存入消息队列，这样可以抵御大量的并发订单请求对系统和数据库的冲击。目前，绝大多数的电商网站即便不进行促销活动，订单系统都采用了消息队列来处理。   
③ 使用集群。   
④ 代码优化：   
- 多线程：基于Java的Web开发基本上都通过多线程的方式响应用户的并发请求，使用多线程技术在编程上要解决线程安全问题，主要可以考虑以下几个方面：A. 将对象设计为无状态对象（这和面向对象的编程观点是矛盾的，在面向对象的世界中被视为不良设计），这样就不会存在并发访问时对象状态不一致的问题。B. 在方法内部创建对象，这样对象由进入方法的线程创建，不会出现多个线程访问同一对象的问题。使用ThreadLocal将对象与线程绑定也是很好的做法，这一点在前面已经探讨过了。C. 对资源进行并发访问时应当使用合理的锁机制。 
- 非阻塞I/O： 使用单线程和非阻塞I/O是目前公认的比多线程的方式更能充分发挥服务器性能的应用模式，基于Node.js构建的服务器就采用了这样的方式。Java在JDK 1.4中就引入了NIO（Non-blocking I/O）,在Servlet 3规范中又引入了异步Servlet的概念，这些都为在服务器端采用非阻塞I/O提供了必要的基础。 
- 资源复用：资源复用主要有两种方式，一是单例，二是对象池，我们使用的数据库连接池、线程池都是对象池化技术，这是典型的用空间换取时间的策略，另一方面也实现对资源的复用，从而避免了不必要的创建和释放资源所带来的开销。

## 什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？
- XSS（Cross Site Script，跨站脚本攻击）是向网页中注入恶意脚本在用户浏览网页时在用户浏览器中执行恶意脚本的攻击方式。跨站脚本攻击分有两种形式：反射型攻击（诱使用户点击一个嵌入恶意脚本的链接以达到攻击的目标，目前有很多攻击者利用论坛、微博发布含有恶意脚本的URL就属于这种方式）和持久型攻击（将恶意脚本提交到被攻击网站的数据库中，用户浏览网页时，恶意脚本从数据库中被加载到页面执行，QQ邮箱的早期版本就曾经被利用作为持久型跨站脚本攻击的平台）。XSS虽然不是什么新鲜玩意，但是攻击的手法却不断翻新，防范XSS主要有两方面：消毒（对危险字符进行转义）和HttpOnly（防范XSS攻击者窃取Cookie数据）。 
- SQL注入攻击是注入攻击最常见的形式（此外还有OS注入攻击（Struts 2的高危漏洞就是通过OGNL实施OS注入攻击导致的）），当服务器使用请求参数构造SQL语句时，恶意的SQL被嵌入到SQL中交给数据库执行。SQL注入攻击需要攻击者对数据库结构有所了解才能进行，攻击者想要获得表结构有多种方式：（1）如果使用开源系统搭建网站，数据库结构也是公开的（目前有很多现成的系统可以直接搭建论坛，电商网站，虽然方便快捷但是风险是必须要认真评估的）；（2）错误回显（如果将服务器的错误信息直接显示在页面上，攻击者可以通过非法参数引发页面错误从而通过错误信息了解数据库结构，Web应用应当设置友好的错误页，一方面符合最小惊讶原则，一方面屏蔽掉可能给系统带来危险的错误回显信息）；（3）盲注。防范SQL注入攻击也可以采用消毒的方式，通过正则表达式对请求参数进行验证，此外，参数绑定也是很好的手段，这样恶意的SQL会被当做SQL的参数而不是命令被执行，JDBC中的PreparedStatement就是支持参数绑定的语句对象，从性能和安全性上都明显优于Statement。 
- CSRF攻击（Cross Site Request Forgery，跨站请求伪造）是攻击者通过跨站请求，以合法的用户身份进行非法操作（如转账或发帖等）。CSRF的原理是利用浏览器的Cookie或服务器的Session，盗取用户身份，其原理如下图所示。防范CSRF的主要手段是识别请求者的身份，主要有以下几种方式：（1）在表单中添加令牌（token）；（2）验证码；（3）检查请求头中的Referer（前面提到防图片盗链接也是用的这种方式）。令牌和验证都具有一次消费性的特征，因此在原理上一致的，但是验证码是一种糟糕的用户体验，不是必要的情况下不要轻易使用验证码，目前很多网站的做法是如果在短时间内多次提交一个表单未获得成功后才要求提供验证码，这样会获得较好的用户体验。

## 聊聊你所处理过的技术难点？

## 聊聊你们的系统架构？

# 参考文献
[Java 面试题：百度前200页都在这里了](http://www.importnew.com/27326.html)             
[Java 面试题全集上](http://blog.csdn.net/jackfrued/article/details/44921941)          
[Java 面试题全集中](https://blog.csdn.net/jackfrued/article/details/44931137)          
[Java 面试题全集下](http://blog.csdn.net/jackfrued/article/details/44931161)                                                