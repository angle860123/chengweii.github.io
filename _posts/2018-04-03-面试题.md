---
layout: post
title: 面试题
subtitle: 常见面试题汇总。
date: 2018-04-03
author: chengweii
header-img: img/post-bg-hacker.jpg
catalog: true
tags:
    - 面试
    - java
---

# 基本概念
## 什么是面向对象编程？
通过建模形式抽象思维过程的编程方法。面向对象编程的核心思想体现在四个方面：抽象、封装、继承、多态。  
* 抽象
    * 抽象是定义对象的属性和行为，具体体现为将同一类对象(模型)的数据和行为定义为类。
* 封装
    * 封装是一种信息隐蔽技术，隐藏一切可隐藏的数据或行为，只对外提供最简单的操作数据的接口。
* 继承
    * 继承是从已有类得到继承信息创建新类的过程。继承不仅支持了系统的可重用性，而且还促进了系统的可扩充性。
* 多态
    * 多态是指允许不同子类型的对象对同一消息作出不同的响应。   
    
## 操作系统中heap和stack的区别？
1.功能方面，Stack空间用来存储基础类型的值和对象引用，Heap则用来存储对象和数组。  
2.使用方面，Stack空间由操作系统自动分配释放，Heap空间由程序员手动申请释放。  
3.限制方面，Stack空间有限，Heap则是空间很大的自由区。  
4.效率方面，Stack简单、速度快；Heap灵活，但是速度慢且容易产生内存碎片。  

## 什么是AOP？
切面编程（AOP）是通过切面非侵入式的操作程序方法，常用的场景如日志记录、权限判断、读写分离等，其原理是基于动态代理技术实现，通过ProxyBeanFactory配置工厂bean，将实现MethodInterceptor接口的拦截器织入拦截器链完成方法调用拦截。具体实现是通过@AspectJ注解将Bean转换为一个aspectj切面，通过@Pointcut、@Before、@After、@Around注解定制具体的切面织入的内容。  

## 什么是IOC？
IOC/DI:控制反转，本质是将原来程序中对象创建、依赖的代码，反转交由容器去协助实现以达到统一管理对象的目的。Spring中的IOC容器，它的主要作用是完成对象的创建和依赖的管理注入等等。

## 什么是ORM？

## 什么是反射？

## 事务特性ACID是什么？

## 数据库隔离级别是有哪些？

## 阐述下SOLID原则？

## BS与CS架构的联系与区别？

## JRE、JDK、JVM、JIT的联系与区别？
JRE代表 Java 运行时（Java run-time），是运行 Java 引用所必须的。  
JDK代表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java 编译器，它也包含 JRE。  
JVM代表 Java 虚拟机（Java virtual machine），它的责任是运行 Java 应用。  
JIT 代表即时编译（Just In Time compilation），当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被转换为本地代码，这样有利大幅度提高 Java 应用的性能。  

## MVC是什么，具体如何实现？ 

## RPC 和 RMI 区别？
RPC是远程过程调用协议，通过网络从远程计算机上请求调用某种服务，具体应用有Dubbo；RMI是远程方法调用框架，JAVA中通过RMI实现跨JVM进行远程方法调用。二者的区别是：  
1.二者方法调用的方式不同，RPC是通过网络协议向远程主机发送请求，而RMI则是通过在客户端的Stub对象作为接口进行远程方法调用。  
2.二者适用语言范围不同，RPC是网络协议，与操作系统和语言无关，而RMI则只适用于JAVA。
3.二者调用结果的返回形式不同，RPC传送的消息由外部数据表示 (ExternalData Representation,XDR) 语言表示，这种语言抽象了字节序类和数据类型结构之间的差异。只有由 XDR 定义的数据类型才能被传递， RPC 不允许传递对象。而RMI调用远程对象方法，允许方法返回 Java 对象以及基本数据类型。

# 基础
## String是最基本的数据类型吗？
不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（reference type），Java 5以后引入的枚举类型也算是一种比较特殊的引用类型。

## float f=3.4;是否正确？
不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。 

## short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？ 
对于short s1=1; s1=s1+1;由于1是int类型，因此s1+1运算结果也是int型，需要强制转换类型才能赋值给short型。而short s1=1; s1+=1;可以正确编译，因为s1+=1;相当于s1=(short)(s1 + 1);其中有隐含的强制类型转换。

## &和&&的区别？
&运算符有两种用法：(1)按位与；(2)逻辑与。&&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&&之所以称为短路运算是因为，如果&&左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。

## Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？ 
Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。

## switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？ 
在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。

## 用最有效率的方法计算2乘以8？ 
2 << 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。

## 对象的hashCode有什么要求？
1.两个相同的对象必须要有相同的hashCode，两个不相等的对象允许有相同的 hashcode 值  
2.对象的hashCode必须始终是一致的，不可以是随机数  

## 为什么在重写 equals 方法的时候需要重写 hashCode 方法？
因为有强制的规范指定需要同时重写 hashCode 与 equals 方法，许多容器类，如 HashMap、HashSet 都依赖于 hashCode 与 equals 的规定。

## “a==b”和”a.equals(b)”有什么区别？
如果 a 和 b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。

## 是否可以继承String类？ 
String 类是final类，不可以被继承。

## String和StringBuilder、StringBuffer的区别？ 
Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。

## 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？ 
方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。不能根据返回类型来区分重载。

## 为什么不能根据返回类型区分重载？
因为调用时如果不能指定返回类型信息时，编译器是不知道你要调用哪个函数的，函数的返回值只是作为函数运行之后的一个“状态”，并不能作为某个方法的“标识”。

## char 型变量中能不能存贮一个中文汉字，为什么？ 
char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16比特），所以放一个中文是没问题的。

## 抽象类（abstract class）和接口（interface）有什么异同？ 
相同：
1.抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。  
2.一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。  
不同：  
1.接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。  
2.抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。  
3.抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。  

## 阐述静态变量和实例变量的区别。 
1.静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝。  
2.实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。

## 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？
不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。

## 如何实现对象克隆？ 
有两种方式： 
1). 实现Cloneable接口并重写Object类中的clone()方法。  
2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。

## final、finalize 和 finally 的不同之处？
final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变；修饰类，表示该类不能被继承；修饰方法，表示方法不能被重写。  
finalize 方法是在对象被回收之前调用的方法，给对象自己最后一个复活的机会，但是如同对象何时被GC无法被保证，什么时候调用 finalize 也无法保证。  
finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。  

## 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？ 
一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。

## Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？
可以继承其他类或实现其他接口，在Android开发中常用此方式来实现事件监听和回调。

## Error和Exception有什么区别？
Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。

## try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后? 
会执行，在方法返回调用者前执行。

## 列出一些你常见的运行时异常？ 
- ArithmeticException（算术异常）  
- ClassCastException （类转换异常）   
- IllegalArgumentException （非法参数异常）   
- IndexOutOfBoundsException （下标越界异常）   
- NullPointerException （空指针异常）   
- SecurityException （安全异常）  

## 实现集合排序的方式有哪些？
1.使用有序集合，如 TreeSet、TreeMap，注意如果不提供Comparator的话，对象需实现Comparable接口,重写其compareTo()方法  
2.使用顺序集合，如 List（ArrayList、LinkedList），然后通过 Collections.sort(List<T> list) 来排序，对象需实现Comparable接口,重写其compareTo()方法

## 

## List、Set、Map 和 Queue 之间的区别？
List 是一个有序集合，允许元素重复。它的某些实现可以提供基于下标值的常量访问时间，但是这不是 List 接口保证的。Set 是一个无序集合。

## poll() 方法和 remove() 方法的区别？
poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。

## Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？
PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，但是 LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。

## ArrayList 与 LinkedList 的不区别？
最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。

## 写一段代码在遍历 ArrayList 时移除一个元素？
通过Iterator遍历时不可进行更新操作，通过索引遍历（for(index=0;index<list.size();index++){list.get(index);}）时则可以。

## ArrayList 和 HashMap 的默认大小是多少？
在 Java 7 中，ArrayList 的默认大小是 10 个元素，HashMap 的默认大小是16个元素（必须是2的幂）。这就是 Java 7 中 ArrayList 和 HashMap 类的代码片段：
```java
// from ArrayList.java JDK 1.7
private static final int DEFAULT_CAPACITY = 10;
//from HashMap.java JDK 7
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
```

# 多线程
## Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别? 
sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态）。  
wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。

## 编写多线程程序有几种实现方式？ 
Java 5以前实现多线程有两种实现方法：一种是继承Thread类；另一种是实现Runnable接口。  
两种方式都要通过重写run()方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了，显然使用Runnable接口更为灵活。注意：Thread类也是Runnable接口的子类。  
Java 5以后创建线程还有第三种方式：实现Callable接口，配合线程池框架使用，该接口中的call方法可以在线程执行结束时产生一个返回值。  
```java
ExecutorService threadPool = Executors.newSingleThreadExecutor();
Future<String> future = threadPool.submit(new MyThread());
```

## 启动一个线程是调用run()还是start()方法？ 


# JVM
## 描述一下JVM加载class文件的原理机制？
JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。 
由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。 
类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：

Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；
Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；
System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。

## 解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。 
通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用JVM中的栈空间；而通过new关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor（又可分为From Survivor和To Survivor）、Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的100、"hello"和常量都是放在常量池中，常量池是方法区的一部分，。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发StackOverflowError，而堆和常量池空间不足则会引发OutOfMemoryError。

## GC是什么？为什么要有GC？


## 你能保证 GC 执行吗？
不能，虽然你可以调用 System.gc() 或者 Runtime.gc()，但是没有办法保证 GC 的执行。

# 开放性问题
## 比较一下Java和JavaSciprt
1.面向对象和基于对象：Java是一种面向对象语言，必须设计对象，而后进行编程；JavaScript是一种脚本语言，基于对象（Object-Based）和事件驱动（Event-Driven）进行编程。  
2.编译和解释：Java的源代码在执行之前，必须经过编译，而后再进行解释执行。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器直接解释执行。   
3.强类型和弱类型：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。 

# 参考文献
[Java 面试题：百度前200页都在这里了](http://www.importnew.com/27326.html)                                                                 