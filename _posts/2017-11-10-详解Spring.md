---
layout: post
title: 详解Spring
subtitle: 深入了解Spring的原理与应用
date: 2017-11-10
author: chengweii
header-img: img/post-bg-hacker.jpg
catalog: true
tags:
    - Spring
    - java
---

# Spring
> Spring是一个基于分层架构的开源框架，为J2EE企业应用程序提供一站式的解决方案。

![Spring架构](/img/spring/spring-1.jpg)
Spring是一个开源框架，是为了解决企业应用程序开发复杂性而创建的。  
框架的主要优势之一就是其分层架构，分层架构允许您选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。  
它是一个全面的、企业应用开发一站式的解决方案，贯穿表现层、业务层、持久层，但是Spring仍然可以和其他的框架无缝整合。  
Spring框架的开发不是为了替代现有的优秀第三方框架，而是通过集成的方式把它们都连接起来。以下框架为在开发中集成的优秀框架：  
权限（shiro）、缓存（Ehcache、Redis）、持久层框架（Hibernate、Mybatis）、定时任务（quartz、spring-task）、Web框架（Spring-MVC、Struts）、RPC框架（Dubbo）等

## IOC
> IOC/DI:控制反转，本质是将原来程序中对象创建、依赖的代码，反转交由容器去协助实现以达到统一管理对象的目的。

Spring中的IOC容器，它的主要作用是完成对象的创建和依赖的管理注入等等。Spring Bean的创建是典型的工厂模式，IOC容器的具体实现就是一系列的Bean工厂，它为开发者管理对象间的依赖关系提供了很多便利和基础服务。
![Spring IOC概要模型](/img/spring/spring-ioc-2.jpg)
![Spring IOC概要类图](/img/spring/spring-ioc-1.png)

### BeanFactory加载Bean的核心实现
以下是BeanFactory加载Bean的核心代码实现：
```java
//AbstractApplicationContext.refresh
public void refresh() throws BeansException, IllegalStateException {
   synchronized (this.startupShutdownMonitor) {
       //调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识  
       prepareRefresh();
       //告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从子类的refreshBeanFactory()方法启动
       ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
       //为BeanFactory配置容器特性，例如类加载器、事件处理器等
       prepareBeanFactory(beanFactory);
       try {
           //为容器的某些子类指定特殊的BeanPost事件处理器
           postProcessBeanFactory(beanFactory);
           //调用所有注册的BeanFactoryPostProcessor的Bean
           invokeBeanFactoryPostProcessors(beanFactory);
           //为BeanFactory注册BeanPost事件处理器。BeanPostProcessor是Bean后置处理器，用于监听容器触发的事件  
           registerBeanPostProcessors(beanFactory);
           //初始化信息源，和国际化相关
           initMessageSource();
           //初始化容器事件传播器
           initApplicationEventMulticaster();
           //调用子类的某些特殊Bean初始化方法
           onRefresh();
           //为事件传播器注册事件监听器
           registerListeners();
           //初始化所有剩余的单例Bean
           finishBeanFactoryInitialization(beanFactory);
           //初始化容器的生命周期事件处理器，并发布容器的生命周期事件
           finishRefresh();
       }
       catch (BeansException ex) {
           //销毁以创建的单态Bean  
           destroyBeans();
           //取消refresh操作，重置容器的同步标识
           cancelRefresh(ex);
           throw ex;
       }
   }
}
```
这段代码主要包含这样几个步骤：  
* 构建 BeanFactory
* 注册可能感兴趣的事件
* 创建 Bean 实例对象
* 触发被监听的事件

#### 构建 BeanFactory
在这个方法中，先判断BeanFactory是否存在，如果存在则先销毁beans并关闭beanFactory，接着创建DefaultListableBeanFactory，并调用loadBeanDefinitions(beanFactory)装载bean定义。
```java
//AbstractRefreshableApplicationContext.refreshBeanFactory
protected final void refreshBeanFactory() throws BeansException {
   if (hasBeanFactory()) {//如果已经有容器，销毁容器中的bean，关闭容器  
       destroyBeans();
       closeBeanFactory();
   }
   try {
        //创建IoC容器  
        DefaultListableBeanFactory beanFactory = createBeanFactory();
        beanFactory.setSerializationId(getId());
       //对IoC容器进行定制化，如设置启动参数，开启注解的自动装配等  
       customizeBeanFactory(beanFactory);
       //调用载入Bean定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器  
       loadBeanDefinitions(beanFactory);
       synchronized (this.beanFactoryMonitor) {
           this.beanFactory = beanFactory;
       }
   }
   catch (IOException ex) {
       throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);
   }
}
```
其中载入Bean定义的loadBeanDefinitions方法是后续创建Bean实例对象的关键前提步骤，它的主要内容是加载、解析 Bean 的定义，然后存储到Spring IOC容器(BeanFactory)中。以下是部分关键代码：
```java
//BeanDefinitionReaderUtils.registerBeanDefinition：将解析的BeanDefinitionHolder注册到容器中 
public static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
    throws BeanDefinitionStoreException {
        //获取解析的BeanDefinition的名称
        String beanName = definitionHolder.getBeanName();
        //向IoC容器注册BeanDefinition 
        registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
        //如果解析的BeanDefinition有别名，向容器为其注册别名  
        String[] aliases = definitionHolder.getAliases();
        if (aliases != null) {
            for (String aliase : aliases) {
                registry.registerAlias(beanName, aliase);
            }
        }
}
//DefaultListableBeanFactory.registerBeanDefinition
public class DefaultListableBeanFactory 
    extends AbstractAutowireCapableBeanFactory 
    implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable {
    public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
        throws BeanDefinitionStoreException {
        //...
        this.beanDefinitionNames.add(beanName);
        //...
        this.beanDefinitionMap.put(beanName, beanDefinition);
        //...
    }
}
```
> 注意：BeanDefinitionRegistry的具体实现类其实是以上构建的BeanFactory(DefaultListableBeanFactory)，
而最终加载、解析的Bean定义会存储到BeanFactory的成员beanDefinitionMap、beanDefinitionNames中。

#### 注册可能感兴趣的事件
创建好 BeanFactory 后，接下去添加一些 Spring 本身需要的一些工具类，这个操作在 AbstractApplicationContext 的 prepareBeanFactory 方法完成。  
接下来的postProcessBeanFactory、invokeBeanFactoryPostProcessors、registerBeanPostProcessors是对 Spring 的功能进行扩展。其中postProcessBeanFactory、invokeBeanFactoryPostProcessors主要是让你现在可以对已经构建的 BeanFactory 的配置做修改，而registerBeanPostProcessors就是让你可以对以后再创建 Bean 的实例对象时添加一些自定义的操作。  
而initMessageSource、initApplicationEventMulticaster、registerListeners是初始化监听事件和对系统的其他监听者的注册，监听者必须是 ApplicationListener 的子类。
```java
//BeanFactoryPostProcessor.postProcessBeanFactory：在 invokeBeanFactoryPostProcessors 方法中主要是获取实现 BeanFactoryPostProcessor 接口的子类的Bean实例。并调用它的 postProcessBeanFactory 方法
public interface BeanFactoryPostProcessor {
    void postProcessBeanFactory(ConfigurableListableBeanFactory var1) throws BeansException;
}
//BeanPostProcessor.postProcessBeforeInitialization、BeanPostProcessor.postProcessAfterInitialization
//registerBeanPostProcessors 方法也是可以获取用户定义的实现了 BeanPostProcessor 接口的子类，并把它们注册到 BeanFactory 对象中的 beanPostProcessors 变量中。BeanPostProcessor 中声明了两个方法：postProcessBeforeInitialization、postProcessAfterInitialization 分别用于在 Bean 对象初始化时执行，其中可以定义用户自己的操作。
public interface BeanPostProcessor {
    Object postProcessBeforeInitialization(Object var1, String var2) throws BeansException;
    Object postProcessAfterInitialization(Object var1, String var2) throws BeansException;
}
```

#### 创建 Bean 实例对象
Bean 的实例化是在 BeanFactory 中完成的。其中核心代码在 preInstantiateSingletons 方法中：
```java
//AbstractApplicationContext.finishBeanFactoryInitialization
protected void finishBeanFactoryInitialization(
    ConfigurableListableBeanFactory beanFactory) { 
 
    // Stop using the temporary ClassLoader for type matching. 
    beanFactory.setTempClassLoader(null); 
 
    // Allow for caching all bean definition metadata, not expecting further changes.
    beanFactory.freezeConfiguration(); 
 
    // Instantiate all remaining (non-lazy-init) singletons. 
    beanFactory.preInstantiateSingletons(); 
}
```

## AOP


## Bean管理
Spring Bean是被实例的，组装的及被Spring 容器管理的Java对象。Spring容器会自动完成bean对象的实例化。创建应用对象之间的协作关系的行为称为：装配(wiring)，这就是依赖注入的本质。
### Bean的创建
Bean的创建过程由Spring容器对对象实例、组装的过程。  
只有被注册的类型才会被Spring管理，通过@Component,@Repository,@Controller,@Service,@Configration这些注解可以将要使用的对象的类型注册到Spring容器中。  
被注册的类型被实例化为对象之后，还需要通过组装将对象、属性、方法关联到一起，才能使用。属性组装时通过@Autowired(根据类型)、@Resource(根据名称)这些注解完成。
### Bean的生命周期
Bean的作用域有singleton(单例)、prototype(非单例)、(session、request、global session)(不常用，Web作用域，基于Web容器(Servlet)或框架(Portlet))。
#### singleton(单例)
当一个bean的作用域设置为singleton, 那么Spring IOC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。
#### prototype(非单例)
prototype作用域部署的bean，每一次请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）都会产生一个新的bean实例。
> 不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法，而对prototype而言，任何配置好的析构生命周期回调方法都将不会被调用。 清除prototype作用域的对象并释放任何prototype bean所持有的昂贵资源，都是客户端代码的职责。

## 事务
## 扩展

# 参考文献
[1000行代码读懂Spring（一）- 实现一个基本的IoC容器](https://my.oschina.net/flashsword/blog/192551)  
[Spring：源码解读Spring IOC原理](https://www.cnblogs.com/ios9/p/7475250.html)  
[Spring多种加载Bean方式简析](https://www.cnblogs.com/lizo/p/6759080.html)  
[Spring技术内幕——深入解析Spring架构与设计原理（二）AOP](http://jiwenke.iteye.com/blog/494620)  
[Spring 框架的设计理念与设计模式分析](https://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/)  
[BeanPostProcessor与AB测试](https://www.jianshu.com/p/1417eefd2ab1)  
[Spring思维导图，让spring不再难懂（一）](https://www.jianshu.com/p/6b15246a48db)  
[Spring思维导图，让Spring不再难懂（ioc篇）](https://www.jianshu.com/p/a6144d2035a8)  
[Spring思维导图，让Spring不再难懂（aop篇）](https://www.jianshu.com/p/7b74ad5ffb76)  